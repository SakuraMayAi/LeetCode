问题链接：https://leetcode.cn/problems/sliding-window-maximum/description/

# 解法一

对于本题，传统的做法就是维护一个双端队列，队首在左边，队尾在右边。移动滑动窗口时，左边的元素会从队首出队，右边的元素会从队尾入队。每次移动过后，都去寻找该窗口内的最大值，找出后放入存放最大值的数组，最后返回该数组。

当然可以使用大顶堆来维护滑动窗口中的元素，因为大顶堆顶部的元素一定是最大值。但是滑动窗口是动态的，进一个元素的同时，还得出一个元素，如何确定出去的是哪个元素（不能想当然认为出去的元素是 `nums` 上确定的，因为数组可能存在同样的值），这是大顶堆不能解决的问题。

问题难点在于，**移动窗口后如何确定最大值**？如果每次都扫描一遍窗口，时间复杂度就是 $O(n * k)$；即便做了一些诸如判断进队的元素是否比最大值还大、出队的元素是否为最大值等剪枝操作，最坏情况下的时间复杂度仍然会达到 $O(n * k)$，这样必定会超时。因为只要维护着滑动窗口那么大的队列，时间复杂度就不可能会降下来。

所以解决问题的关键在于维护队列的大小。如果说我们每次移动窗口后，队首元素都是当前窗口的最大值。而且我们也并不维护窗口中的所有元素，只维护**有可能成为窗口里最大值的元素**就，就能将时间复杂度减少很多。此时只需要保证队列里的元素是由大到小排序的即可。这样一个元素**单调递减**或者**单调递增**的队列就是一个**单调队列**。

我们仍然维护一个双端队列 `dequ`。滑动窗口是从数组的最左边到最右边，如果用 i 去枚举数组的索引，那么 nums[i] 就是要入队的元素。

对于要进队的元素 `x`，先将它与当前队尾的元素 `dequ.back()` 进行比较。如果 `x > dequ.back()`，说明 `x` 更有可能成为最大值，所以我们不再需要 `dequ.back()`，将其弹出即可。然后继续比较，直到 `x` 不超过队尾的元素，再将其插入队尾。这样组维护队列中元素值一定是由大到小的。

但是队列不能只进不出，否则只会越来越大，越来越难维护。入队一个元素，就要出队一个元素。对于要出队的元素 `y`，我们需要将其与滑动窗口中
