问题链接：https://leetcode.cn/problems/sliding-window-maximum/description/

# 解法：单调队列（又称优先级队列）

对于本题，传统的做法就是维护一个双端队列，队列中的元素就是滑动窗口中的元素，队首在左边，队尾在右边。移动滑动窗口时，左边的元素会从队首出队，右边的元素会从队尾入队。每次移动过后，都去寻找该窗口内的最大值，找出后放入存放最大值的数组，最后返回该数组。

当然可以使用大顶堆来维护滑动窗口中的元素，因为大顶堆顶部的元素一定是最大值。但是滑动窗口是动态的，进一个元素的同时，还得出一个元素，如何确定出去的是哪个元素（不能想当然认为出去的元素是 `nums` 上确定的，因为数组可能存在同样的值），这是大顶堆不能解决的问题。

问题难点在于，**移动窗口后如何确定最大值**？如果每次都扫描一遍窗口，时间复杂度就是 $O(n * k)$；即便做了一些诸如判断进队的元素是否比最大值还大、出队的元素是否为最大值等剪枝操作，最坏情况下的时间复杂度仍然会达到 $O(n * k)$，这样必定会超时。因为只要维护着滑动窗口那么大的队列，时间复杂度就不可能会降下来。

所以解决问题的关键在于维护队列的大小。如果说类似于大顶堆，我们每次移动窗口后，队首元素都是当前窗口的最大值，就不需要扫描一遍队列了；而且如果我们不维护窗口中的所有元素，只维护**有可能成为窗口里最大值的元素**，就能将时间复杂度减少很多。此时只需要保证队列里的元素是由大到小排序的即可。这样一个元素**单调递减**或者**单调递增**的队列就是一个**单调队列**。

我们仍然维护一个双端队列 `dequ`。滑动窗口是从数组的最左边移动到最右边，如果用 `i` 去枚举数组的索引，那么 `nums[i]` 就是要入队的元素，`nums[i - k]` 就是要出队的元素。

对于要入队的元素 `nums[i]`，先将它与队尾的元素 `dequ.back()` 进行比较。如果 `nums[i] > dequ.back()`，说明 `nums[i]` 比 `dequ.back()` 更有可能成为最大值，将其弹出即可。然后继续比较，直到 `nums[i]` 不超过队尾的元素，再将其插入队尾。这样组维护队列中的元素值一定是由大到小排列，而且也不用维护那么多的元素。

但是队列不能只进不出，否则只会越来越大。入队一个元素，就要出队一个元素。对于要出队的元素 `nums[i - k]`，只要它不等于最大值 `dequ.front()`，我们就不需要做任何操作，因为该元素并不会影响到下一个窗口的最大值的变化；但如果 `nums[i - k] = dequ.front()`，就需要将队首的最大值弹出，因为它已经不属于下一个窗口了，自然也不会成为下一个窗口的最大值。

上面便是维护队列的核心过程，不理解的读者可以手动模拟一下，更能够理解上面这段话的含义。代码中要注意一下，对于第一个窗口，要先到第 `k` 个元素入队后再开始

```cpp
void push(deque<int>& dequ, int x)
{
    while (!dequ.empty() && x > dequ.back())
        dequ.pop_back();    // 队尾元素更小，所以出队
    dequ.push_back(x);
}

vector<int> maxSlidingWindow(vector<int>& nums, int k)
{
    deque<int> dequ;
    vector<int> res;
    for (int i = 0; i < k; ++i)
        push(dequ, nums[i]);
    res.push_back(dequ.front());    // 别忘记第一个窗口的最大值
    for (int i = k; i < nums.size(); ++i)
    {
        if (!dequ.empty() && dequ.front() == nums[i - k])
            dequ.pop_front();   // 先出队，否则新的最大值可能被弹出
        push(dequ, nums[i]);
        res.push_back(dequ.front());
    }

    return res;
}
```
