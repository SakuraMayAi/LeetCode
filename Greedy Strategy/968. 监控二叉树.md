问题链接：https://leetcode.cn/problems/binary-tree-cameras/description/

# 解法：贪心 && 状态递归

从根节点开始**递归返回**，在每一个根节点的父节点处放置一个摄像头，因为这样可以最大化利用摄像头的监视范围。对于再往上层的每一个节点，需要根据**下层的状态值**，来判断其所处的状态，然后向其上层递归返回其**自身的状态值**，从而在整体上减少摄像头的数量。全局变量 `res` 记录摄像头的数量。

对于每个节点而言，其只有三种状态（用三个状态值分别进行标记）：
- **0 被监视**。
- **1 有摄像头**。
- **2 无监视**。

对于这三个数字，两两结合且可重复的话，总共有9种情况：
- `[0, 0]`，`[1, 1]`，`[2, 2]`。
- `[0, 1]`，`[1, 0]`。
- `[0, 2]`，`[2, 0]`。
- `[1, 2]`，`[2, 1]`。

接下来需要做的就是确定好状态判断的逻辑，我们分别进行讨论（左右孩子状态值对称的情况，得到的当前节点的状态都是一样的，所以可以放在一起讨论）：

1. `[0, 0]`
两个孩子都被监视，则当前节点无监视，返回2。

2. `[1, 1]`
两个孩子都有摄像头，则当前节点被监视，返回0。

3. `[2, 2]`
两个孩子都无监视，则当前节点需要放置摄像头监视左右孩子，返回1。

4. `[0, 1]` 和 `[1, 0]`
一个孩子被监视，一个孩子有摄像头，则当前节点被监视，返回0。

5. `[0, 2]` 和 `[2, 0]`
一个孩子被监视，一个孩子无监视，则当前节点需要放置摄像头监视孩子，返回1。

6. `[1, 2]` 和 `[2, 1]`
一个孩子有摄像头，一个孩子无监视，则当前节点需要放置摄像头监视孩子，返回1。

那么总结一下上面的规律就是：
1. 只有当两个孩子**都被监视**时，当前节点可以由其**父节点**进行监视，所以返回2；
2. **只要有一个孩子无监视**，当前结点都必须放置摄像头，所以返回1；
3. 剩余的都返回0。

递归返回根节点时，还需要再判断一下根节点的状态，如果根节点无监视，就返回 `res + 1`；否则直接返回 `res` 即可。


```cpp
int res = 0;
int Traversal(TreeNode* cur)
{
    if (!cur) return 0; // 空节点默认被监视
    int left = Traversal(cur->left);
    int right = Traversal(cur->right);
    if (left == 0 && right == 0)
        return 2;
    else if (left == 2 || right == 2)
    {
        ++res;
        return 1;
    }
    else return 0;
}

int minCameraCover(TreeNode* root)
{
    return Traversal(root) == 2 ? res + 1 : res;
}
```
