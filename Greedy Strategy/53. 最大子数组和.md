问题链接：https://leetcode.cn/problems/maximum-subarray/description/

# 解法：贪心

对于序列中的某一个连续的子序列，如果该子序列的连续**小于等于**零，应该从**子序列的下一个元素**开始**重新计算连续和**。

举个例子：对于子序列 `{1,2,3,-7,4}`，前三个元素的连续和 `sum` 为 6，当加上第四个元素时，连续和就变成了-1，此时应该将 `sum` 置0，然后从4开始重新计算连续和。

可能有的读者会认为，可能前面的**子序列的子序列**，比如 {2,3}，加上-7，再和后面的连续数字加在一起后会出现更大的和。这个是肯定不会的，证明如下：

假设有子序列 `{X,y,z}`，其中 `X` 代表一个**子序列**，`y` 是一个**数**，且 `X > 0，X + y < 0`。那么对于子序列 `X` ，去除掉**任意前部分元素**后得到的子序列 `x` 一定满足 `x < X`，那么 `x + y` 只会比 `X + y` 更小且是负值。此时其加上后面连续的数字，得到的结果**只会更小不会更大**。可能还有读者会认为，“万一 `X` 是 `{-5,6}` 这样的子序列呢？去掉前面的-5后子序列更大了”。仔细阅读代码后就能知道，`sum` 统计的子序列的**首元素**一定不会是负数。因为判断逻辑保证了最开始的负数都不会加到 `sum` 上，而后只有不会使得连续和小于等于0的负数，才会被加到 `sum` 上。

```cpp
int maxSubArray(vector<int>& nums)
{
    if (nums.empty()) return 0;
    int res = INT_MIN;
    int sum = 0;
    for (int i = 0; i < nums.size(); ++i)
    {
        sum += nums[i];
        if (sum > res) res = sum;
        if (sum <= 0) sum = 0;
    }

    return res;
}
```
