问题链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/

该题的动态规划解法可参考：[122. 买卖股票的最佳时机 II.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II.md)。

# 解法一：贪心（极值）

这一题的本质就是在最低点买入，在紧挨着的最高点卖出。为什么要说是紧挨着的，因为可能整体有许多**局部最低和最高**（其实就是极值，学过高数的同学应该秒懂）。而代码里通过两个 `while` 循环，先后寻找极大值和极小值。每一轮 `for` 循环都找出一个极大值进行卖出，然后找出一个极小值买入。要注意，外层 `for` 循环的 `i < prices.size()`，而 `while` 循环由于需要访问 `prices[i + 1]`，必须满足 `i < prices.size() - 1`。这主要是防止类似于 `{1,2,3,4,5,2,4}` 这种输入，如果把外层 `for` 循环改成 `i < prices.size() - 1`，就会导致漏掉2买入4卖出这个情况。

```cpp
int maxProfit(vector<int>& prices)
{
    if (prices.empty()) return 0;
    int res = 0, buyPrice = prices[0];
    for (int i = 0; i < prices.size(); ++i)
    {
        while (i < prices.size() - 1 && prices[i + 1] >= prices[i]) ++i;    // 到达极大值
        res += prices[i] - buyPrice;    // 极大值卖出
        while (i < prices.size() - 1 && prices[i + 1] <= prices[i]) ++i;    // 到达极小值
        buyPrice = prices[i];           // 极小值买入
    }

    return res;
}
```

# 解法二：贪心（只收集正值）

我们来看这么一个序列 `{1,3,6,2,5}`。基于上一题极值的想法，我们需要先收集极小值1和极大值6，那么这一次买入卖出利润就是5；再手机极小值2和极大值5，那么这一次买入卖出利润就是3。所以总的利润就是8。

题目并没有规定必须在极小值买入和极大值卖出，是因为“贪心”，在这种情况下确实局部利润最优。我们不妨换个思路，将每个后一天减去前一天（也就是说每天买入，隔天卖出再买入），得到一个新的序列 `{2,3,-4,3}`。可以发现，其中所有正值之和，恰好就是总的利润。这就是更极致的“贪心”策略，做到每天最优。

```cpp
int maxProfit(vector<int>& prices)
{
    if (prices.empty()) return 0;
    int res = 0;
    for (int i = 1; i < prices.size(); ++i)
        res += max(prices[i] - prices[i - 1], 0);

    return res;
}
```
