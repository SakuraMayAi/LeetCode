问题链接：https://leetcode.cn/problems/longest-increasing-subsequence/description/

关于最长递增子序列的知识，可以参考 [最长递增子序列问题.md](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/Algorithms%20And%20Data%20Structure/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md)。

该题的动态规划解法可参考 [300. 最长递增子序列（动态规划）.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md)。

# 解法：贪心 + 二分查找

```cpp
int lengthOfLIS(vector<int>& nums)
{
    int len = 1, n = nums.size();
    vector<int> p(n + 1, 1);
    p[len] = nums[0];
    for (int i = 1; i < n; ++i)
    {
        if (nums[i] > p[len])
            p[++len] = nums[i];
        else    // 二分查找
        {
            int l = 1, r = len, k = 0;  // 找不到比 nums[i] 小的数时，就更新 p[1]
            while (l <= r)
            {
                int mid = (l + r) >> 1;
                if (p[mid] < nums[i])
                {
                    k = mid;
                    l = mid + 1;
                }
                else r = mid - 1;
            }
            p[k + 1] = nums[i];
        }
    }

    return len;
}
```
