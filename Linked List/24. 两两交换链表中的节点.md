# 24. 两两交换链表中的节点
Problem Link: https://leetcode.cn/problems/swap-nodes-in-pairs/description/

Solution 1: As is shown in the gif. The key is to define a dummy head node to replace the original node so that all the subsequent operations can be unified into one `while` loop.

<img src="./img/24. 两两交换链表中的节点_1.gif" width="50%" height="50%">
<img src="./img/24. 两两交换链表中的节点_2.gif" width="50%" height="50%">

```cpp
ListNode* swapPairs(ListNode* head)
{
    if (!head) return nullptr;
    ListNode* p = new ListNode(-1, head);
    ListNode* q = head;
    head = p;
    while (q != nullptr && q->next != nullptr)
    {
        ListNode* r = q->next;
        q->next = r->next;
        r->next = q;
        p->next = r;
        p = q;
        q = q->next;
    }
    return head->next;
}
```

Solution 2: Use recursion. Because the problem requires us to swap every two adjacent nodes from the head node, we can mark the first and second nodes with `head` and `next` respectively at each level of recursion, and then pass the third node to the next level of recursion. This process is equivalent to passing the sub-linked list, stripped of the first two nodes, to the next level. The recursive boundary is when the sub-linked list is either empty or contains a single node.
```cpp
ListNode* swapPairs(ListNode* head)
{
    if (head == nullptr || head->next == nullptr)
        return head;
    ListNode* next = head->next;
    head->next = swapPairs(next->next);
    next->next = head;
    return next;
}
```
