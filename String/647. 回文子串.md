问题链接：https://leetcode.cn/problems/palindromic-substrings/description/

# 解法：双指针 + 中心拓展

通常来说，判断一个字符串是否为回文串的方法可以使用双指针法。使用两个指针，分别指向字符串的**首字符**和**尾字符**，当两个指针指向的元素相同时，就同时**向字符串的中心**移动。如果最后两个指针能相遇，就说明字符串是回文串。

现在需要判断字符串中的**任意子串**是否为回文串，且要统计个数。如果我们暴力枚举所有的子串，再依次判断是否为回文串，是必定会超时的。倘若我们换个方向就好做很多了。从字符串的**中心向两侧进行拓展**，当两个指针指向的元素相同时就拓展，否则停止拓展。两个指针每拓展一次，以这两个指针为首元素和尾元素的子串，就是一个新的回文子串。

字符串的中心需要根据长度确定。比如字符串 s1 = "abbca" 的长度是奇数，其中心就是下标为2的位置；而字符串 s2 = "cabaca" 的长度是偶数，其中心就有两个，分别是下标为2和下标为3的位置。对于题目给定的字符串 s 来说，其中**每一个字符**，和**每一对相邻的字符**，都有可能成为一个回文子串的中心，那么如何确定谁会成为中心呢？

在不确定首元素和尾元素的情况下，实际上我们确定不了，因为我们的目的是统计所有回文子串的个数。所以每一个字符、和每一对相邻的字符，我们都需要假设其可能为回文子串的中心，并统计以其为中心的回文子串的个数。

因此做法就是：遍历字符串 `s`，`0 <= i <= n`，`n` 为 `s` 的长度。然后分别以 `i` 为中心，和以 `i` 和 `i + 1` 为中心，计算回文子串的个数，并将其累加到最终的结果 `cnt` 上。

```cpp
int Count(const string& s, int left, int right, int n)
{
    int cnt = 0;
    while (left >= 0 && right < n && s[left] == s[right])
    {
        --left;
        ++right;
        ++cnt;
    }

    return cnt;
}

int countSubstrings(string s)
{
    int cnt = 0, n = s.size();
    for (int i = 0; i < n; ++i)
        cnt += Count(s, i, i, n) + Count(s, i, i + 1, n);

    return cnt;
}
```
