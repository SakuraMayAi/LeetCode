问题链接：https://leetcode.cn/problems/n-queens/description/

# 解法：回溯

对于该问题可参考文章 [全排列、 n 皇后问题、区间贪心以及区间选点问题.md](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/Data%20Structure/%E5%85%A8%E6%8E%92%E5%88%97%E3%80%81%20n%20%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E3%80%81%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E4%BB%A5%E5%8F%8A%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9%E9%97%AE%E9%A2%98.md)。

```cpp
vector<vector<string>> res;
int P[11] = { -1 };	
bool used[11] = { false };

void Backtracking(const int& index, const int& n)
{
    if (index == n + 1) // 能到达递归边界的一定是合法方案
    {
        vector<string> solution;
        for (int i = 1; i <= n; ++i)
        {
            string perm(n, '.');
            perm[P[i] - 1] = 'Q';
            solution.push_back(perm);
        }
        res.push_back(solution);
    }
    for (int x = 1; x <= n; ++x)
    {
        if (used[x] == false)
        {
			bool flag = true;
            for (int pre = 1; pre < index; ++pre)
            {
                if (abs(index - pre) == abs(x - P[pre]))
                {
                    flag = false;
                    break;
                }
            }
			if (flag)
			{
				P[index] = x;
				used[x] = true;
				Backtracking(index + 1, n);
				used[x] = false;
			}
        }
    }
}

vector<vector<string>> solveNQueens(int n)
{
    Backtracking(1, n);
    return res;
}
```
