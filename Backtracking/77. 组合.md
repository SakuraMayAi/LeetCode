问题链接：https://leetcode.cn/problems/combinations/description/

# 解法：回溯

关于递归和回溯的概念，可以参考[递归三部曲和回溯三部曲.md](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/Data%20Structure/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2%E5%92%8C%E5%9B%9E%E6%BA%AF%E4%B8%89%E9%83%A8%E6%9B%B2.md)。

这一题是很经典的回溯问题。因为要从 `n` 个数中选择 `k` 个数，这 `n` 和 `k` 自然就是需要传递的参数。而回溯（递归）的边界即选择了第 `k` 个数，记录这个组合然后返回。我们现在假设 `n = 5`，`k = 3`，那么就会有两个问题需要解决。

一是**如何保证选择的数字不重复**？比如第一层选了1，就得保证后面的层不能选1。

二是**如何保证选择的组合不重复**？比如某一条递归路径中得到的组合是 `[1, 2, 3]`，就不能再出现如 `[2, 1, 3]`，`[3, 2, 1]` 等重复的组合了。

由前面的文章可以知道，我们可以在每一层递归中包含一层循环，**通过循环来选择数字**。如果我们在递归间传递一个参数，来表明当前层递归的循环**只能从第几个数字开始选**，就能保证这两个问题同时得到解决。

比如第一层递归选择了数字1，那么它就指定第二层递归必须从1之后的数字选起；而第二层递归选择了数字3，那么它就指定第三层递归必须从2之后的数字选起，这样就保证了一条递归路径上的数字选择是互斥的。当我们回到第一层递归选择了数字2时，那么它就指定第二层递归必须从2之后的数字选起；而第二层递归选择了数字3，那么它就指定第三层递归必须从3之后的数字选起。这样就能保证不会出现类似 `[1, 2, 3]` 和 `[2, 1, 3]` 这样的重复组合。

参数 `start` 就是用于指定下一层递归开始选择的起点。每一层递归中选择的数字，我们将其加入到 `vector` 对象 `path` 中，表明当前路径上选择的数字。当 `path` 的大小等于 `k` 时就是递归的边界，将路径推入 `res` 中，递归返回。在 `for` 循环中还有一个剪枝的操作。 对于每一层递归，如果说剩余的数字不够选到 `k` 个数，那么往后的递归是没有意义的。比如第一层递归选了4，第二层递归选了5，即使还没选到 `k` 个数，但是剩下的数字不够选了，就没有必要再往后递归了。`k - path.size()` 表明还需要选择多少个数，那么如何判断剩余的数字不够选了。因为我们通过 `start` 来指定开始选择的数字，也就是起点。**起点到末尾的数字个数**正好表明了还可以选择的数字，也即 `n - (k - path.size()) + 1`，当 `start` 一开始就大于 `n - (k - path.size()) + 1`，就直接结束循环，不再往后递归。当然也可以将这个判定放在进入递归之前，或者放在递归的最开始。看读者个人喜好即可。

```cpp
vector<vector<int>> res;
vector<int> path;

void BackTracking(int n, int k, int start)
{
    if (path.size() == k)
    {
        res.push_back(path);
        return;
    }
    for (int i = start; i <= n - (k - path.size()) + 1; ++i)
    {
        path.push_back(i);
        BackTracking(n, k, i + 1);
        path.pop_back();
    }
}

vector<vector<int>> combine(int n, int k)
{
    BackTracking(n, k, 1);
    return res;
}
```

# 解法二：排列组合的性质

利用**排列组合的性质**： $C_{n}^{m} =  C_{n - 1}^{m-1} + C_{n-1}^{m}，C_{n}^{1} = n，C_{n}^{n} = 1$，将问题不停地拆分成子问题进行解决，这就完美符合递归的思想。但是这种拆分，适合于**只需要计算有多少种组合**的场景，现在题目要求的是把每个组合都找出来。
