问题链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/description/

# 解法一：迭代实现

按照正常的层序遍历来即可。这一题独特在于返回的是一个二维 `vector`，每一维都是一层结点的值。因此在弹出结点时，需要记录一下当前队列的大小，其实也就是当前层结点的个数。然后通过 `for` 循环将当前层所有结点弹出，将它们的值存入 `vec`，同时也将所有结点的孩子结点放入队列。在 `for` 循环外，需要将 `vec` 放入最终需要返回的二维 `vector` `seq` 中。

```cpp
vector<vector<int>> levelOrder(TreeNode* root)
{
    if (root == nullptr) return vector<vector<int>>();
    queue<TreeNode*> qu;
    vector<vector<int>> seq;
    qu.push(root);
    while (!qu.empty())
    {
        int size = qu.size();
        vector<int> vec;
        for (int i = 0; i < size; ++i)
        {
            TreeNode* node = qu.front();
            vec.push_back(node->val);
            qu.pop();
            if (node->left) qu.push(node->left);
            if (node->right) qu.push(node->right);
        }
        seq.push_back(vec);
    }

    return seq;
}
```cpp

# 解法二：递归实现
