问题链接：https://leetcode.cn/problems/task-scheduler/description/

# 解法：找规律

题目的意思是一个周期（时间间隔）只能执行一个任务，而同类型的任务之间必须间隔 `n` 个周期，求 CPU 执行完任务列表需要的最少周期。基于此引用评论区一位大佬的解法，并做修改和说明。

假设任务列表为 `tasks = {"A","A","A","B","B","C"}`，`n = 2`，`A` 是频率最高的任务且频率为 `maxf = 3`，那么两个 `A` 之间必须间隔2个周期。对于 A 来说，我们可以写出周期最少的执行顺序：`A X X A X X A`，`X` 表示其他类型的任务或者是 CPU 等待。前 `maxf - 1` 个 `A` 每一个都需要搭配 `n` 个 `X`，最后再加上剩下的 `A`，所以总的执行周期为 `(maxf - 1) * (n + 1) + 1`。

但是有可能会出现多个任务都是频率最高的，比如 `{"A","A","A","B","B","B","C","C"}`，`n = 2`。此时的执行顺序是 `A B X A B X A B`，最后剩下的是 `A B`。其实就相当于将 `A` 换成了 `A B`，因此最后再加上的是频率最高的不同任务的个数 `cnt`，即 `(maxf - 1) * (n + 1) + cnt`。

但是当 `X` 不足以填充除了频率最高的任务以外的任务个数时，这个公式就不适用了。假如任务列表为 `{"A","A","A","B","B","C","C"}`，`n = 1`，那么 `A` 的执行顺序就是 `A X A X A`，按照公式计算总的执行周期就是 `(3 - 1) * (1 + 1) + 1 = 5`。可实际上至少需要7个周期才能执行完，因为理想的执行顺序中只有3个 `X`，不足以填充除了 `A` 之外的4个任务。而出现这个现象的本质原因就是，CPU 在每一个周期都有任务执行，此时的最小执行周期就是任务的个数（数组长度）。换句话说，当我们计算出的执行周期小于数组长度时，返回的应该是数组长度。

```cpp
int leastInterval(vector<char>& tasks, int n)
{
    vector<int> freq(26, 0);
    int cnt = 0, maxf = -1; // 频率最高的不同任务的个数，最大频率
    for (const auto& c : tasks)
    {
        ++freq[c - 'A'];
        maxf = max(maxf, freq[c - 'A']);    // 更新最大频率
    }
    for (const auto& i : freq)
        if (i == maxf) ++cnt;
    int res = (maxf - 1) * (n + 1) + cnt;

    return res >= tasks.size() ? res : tasks.size();
}
```
