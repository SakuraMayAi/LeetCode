问题链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/

本题的动态规划解法可参考 [674. 最长连续递增序列.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.md)。

# 解法：双指针

定义两个指针 `i` 和 `j`，分别指向数组的第一个和第二个元素，区间 `nums[i...j - 1]` 维护了一个连续递增子序列。

遍历数组 `nums`，`1 <= j < nums.size()`：
- 如果 `nums[j] > nums[j - 1]`，说明它俩可以继续构成连续递增子序列，因此将 `j` 后移寻找是否可以更长；
- 如果 `nums[j] <= nums[j - 1]`，则说明连续递增子序列中断了，记录此时子序列的长度，并更新 `len` 的值。随后将 `i` 移到 `j`，作为下一个连续递增子序列的起点，`j` 后移。

退出循环后，`nums[i...j - 1]` 可能维护了一个更长的连续递增子序列，所以还需要更新一次 `len` 的值。

```cpp
int findLengthOfLCIS(vector<int>& nums)
{
    int n = nums.size();
    if (n == 1) return 1; // 数组长度为1时，最长连续递增子序列的长度为1
    int i = 0, j = 1, len = 0;
    while (j < n)
    {
        while (j < n && nums[j] > nums[j - 1]) ++j;
        len = max(len, j - i);
        i = j++;
    }
    len = max(len, j - i);

    return len;
}
```
