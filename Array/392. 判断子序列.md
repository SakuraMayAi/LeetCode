
问题链接：https://leetcode.cn/problems/is-subsequence/description/

本题的动态规划解法可参考 [392. 判断子序列.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.md)。

# 解法：双指针法

定义两个指针 `i` 和 `j`，分别指向字符串 `s` 和 `t` 的首字符。遍历两个字符串，并对 `s[i]` 和 `t[j]` 进行匹配。如果匹配成功，则 `i` 和 `j` 同时向后移，否则只有 `j` 向后移。如果最终 `i` 移动到了 `s` 的末尾，说明 `s` 中所有字符都匹配成功了，即表明 `s` 是 `t` 的子序列。

有一点要注意，对于 `s[i]`，在 `t` 中可能不止一个位置可以匹配，那究竟是匹配哪一个呢？从贪心的策略来上，我们选择匹配**先出现的那个字符**。

假如 `s[i]` 在 `t` 中出现了两次，一个位置在 `j1`，另一个在 `j2`，且 `j1 < j2`。那么匹配 `t[j1]` 是更优的选择。因为在 `t[j2]` 后面出现的字符，同时也在 `t[j1]` 的后面；而先匹配 `t[j1]` 的话，在 `t[j1]` 和 `t[j2]` 之间就有更多的字符可以进行匹配，增大了匹配成功的概率。

```cpp
bool isSubsequence(string s, string t)
{
    int i = 0;
    for (int j = 0; j < t.size(); ++j)
        if (s[i] == t[j]) ++i;

    return i == s.size();
}
```
