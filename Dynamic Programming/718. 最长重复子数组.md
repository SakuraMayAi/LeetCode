问题链接：https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/

# 解法：动态规划

定义 `m` 保存 `nums1` 的长度，`n` 保存 `nums2` 的长度（长度加1防止访问越界）。定义二维数组 `dp[m + 1][n + 1]`，`dp[i][j]` 表示子序列 `nums1[i...m - 1]` 和 `nums2[j...n - 1]` **最长公共前缀**的长度。

以 `nums1 = {1,2,3,2,1}`, `nums2 = {3,2,1,4,7}` 为例。当 `i = 2`，`j = 0` 时，`dp[2][0]` 表示的是子序列 `nums1[2...4] = {3,2,1}` 和 `nums2[0...4] = {3,2,1,4,7}` 的最长公共前缀的长度。这个最长公共前缀是 `{3,2,1}`，所以有 `dp[2][0] = 3`。

暴力解法下，需要从前往后遍历两个数组，此时要考虑所有子序列的情况，并判断其中是否存在相同的子序列。而这个比较过程会存在很多重复的情况，容易导致超时。即便通过去重的方式进行剪枝，剪枝这个操作本身还是会占用很多时间，也很麻烦。

如果我们从后向前遍历数组的所有元素，只考虑子序列 `nums1[i...m - 1]` 和 `nums2[j...n - 1]` 的公共前缀。那么放在整个数组中来看，这个公共前缀其实就是一个**公共子数组**。因为子序列起始的元素不同，前缀也不同，构成的子序列也不同，从而就不用考虑重复的情况。而且可以利用已经计算过的子序列，推导下一个子序列的公共前缀的长度。

### 推导 `dp[i][j]`

定义 `len` 保存数组 `dp` 中的最大值，这个最大值就是两个数组公共的 、长度最长的子数组的长度。遍历数组 `nums1` 和 `nums2`：

- 若 `nums1[i] != nums2[j]`，第一个元素都不匹配，也就不存在公共前缀，继续遍历即可；
- 若 `nums1[i] = nums2[j]`，说明存在公共前缀，接下来该如何判断公共前缀的长度呢？我们可以考虑由 `dp[i + 1][j + 1]` 转移推导。

因为 `dp[i + 1][j + 1]` 表示子序列 `nums1[i + 1...m - 1]` 和 `nums2[j + 1...n - 1]` **最长公共前缀**的长度。设它们的公共前缀是 `k`，因为 `nums1[i] = nums2[j]`，此时 `nums1[i] + k` 就可以构成一个新的、且更长的公共前缀。因此有：

$$dp[i][j] = dp[i + 1][j + 1] + 1$$

交换两个数组的遍历顺序，结果不变。

```cpp
int findLength(vector<int>& nums1, vector<int>& nums2)
{
    int m = nums1.size(), n = nums2.size(), len = 0;
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for (int i = m - 1; i >= 0; --i)
    {
        for (int j = n - 1; j >= 0; --j)
        {
            if (nums2[j] == nums1[i])
            {
                dp[i][j] = dp[i + 1][j + 1] + 1;
                len = max(len, dp[i][j]);   // 出现相等前缀时再更新 len，减少比较时间
            }
        }
    }

    return len;
}
```

# 解法：优化空间复杂度

以 `nums1` `为行遍历，nums2` 为列遍历时，遍历的顺序是由右往左，由下往上的。因此 `dp[i + 1][j + 1]` 处于 `dp[i][j]` 的下一行。因此在内层循环前定义一个 `newDp`，来保存更新后的 `dp`，在内层循环结束后将其拷贝给 `dp`。

```cpp
int findLength(vector<int>& nums1, vector<int>& nums2)
{
    int m = nums1.size(), n = nums2.size(), len = 0;
    vector<int> dp(n + 1, 0);
    for (int i = m - 1; i >= 0; --i)
    {
        vector<int> newDp(n + 1, 0);
        for (int j = n - 1; j >= 0; --j)
        {
            if (nums2[j] == nums1[i])
            {
                newDp[j] = dp[j + 1] + 1;
                len = max(len, newDp[j]);
            }
        }
        dp = newDp;
    }

    return len;
}
```
