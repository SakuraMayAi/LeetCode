问题链接：https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/

# 解法：动态规划

定义 `m` 保存 `nums1` 的长度，`n` 保存 `nums2` 的长度（长度加1防止访问越界）。定义二维数组 `dp[m + 1][n + 1]`，`dp[i][j]` 表示子序列 `nums1[i...m - 1]` 和 `nums2[j...n - 1]` **最长公共前缀**的长度。

以 `nums1 = {1,2,3,2,1}`, `nums2 = {3,2,1,4,7}` 为例。当 `i = 2`，`j = 0` 时，`dp[2][0]` 表示的是子序列 `nums1[2...4] = {3,2,1}` 和 `nums[0...4] = {3,2,1,4,7}` 的最长公共前缀的长度。这两个子序列的最长公共前缀是 `{3,2,1}`，所以有 `dp[2][0] = 3`。

暴力解法下，需要从两个数组的首元素开始往后遍历，此时要考虑所有子序列的情况，并判断其中是否存在相同的子序列。而这个比较过程会存在很多重复的情况，即便通过去重的方式进行剪枝，剪枝这个操作本身还是会占用很多时间，从而导致超时。

### 推导 `dp[i][j]`

定义 `len` 保存数组 `dp` 中的最大值，这个最大值就是两个数组公共的 、长度最长的子数组的长度。

若从数组的尾元素开始往前遍历，我们只需考虑子序列 `nums1[i...m - 1]` 和 `nums2[j...n - 1]` 是否存在公共前缀。若 `nums1[i] = nums2[j]`，说明第一个前缀匹配，接下来该如何呢？

接下来需要查看 `dp[i + 1][j + 1]` 的值。因为`dp[i + 1][j + 1]` 表示子序列 `nums1[i + 1...m - 1]` 和 `nums2[j + 1...n - 1]` **最长公共前缀**的长度。而我们是从后往前遍历的，所以此时的 `dp[i + 1][j + 1]` 已经计算得到了。又由于 `nums1[i] = nums2[j]`，表明匹配的前缀长度变长了，从而可以推导得 `dp[i][j] = dp[i + 1][j + 1] + 1`。

交换两个数组的遍历顺序，结果不变。

```cpp
int findLength(vector<int>& nums1, vector<int>& nums2)
{
    int m = nums1.size(), n = nums2.size(), len = 0;
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for (int i = m - 1; i >= 0; --i)
    {
        for (int j = n - 1; j >= 0; --j)
        {
            if (nums2[j] == nums1[i])
            {
                dp[i][j] = dp[i + 1][j + 1] + 1;
                len = max(len, dp[i][j]);   // 出现相等前缀时再更新 len，减少比较时间
            }
        }
    }

    return len;
}
```

# 解法：优化空间复杂度

以 `nums1` `为行遍历，nums2` 为列遍历时，遍历的顺序是由右往左，由下往上的。因此 `dp[i + 1][j + 1]` 处于 `dp[i][j]` 的下一行。因此在内层循环前定义一个 `newDp`，来保存更新后的 `dp`，在内层循环结束后将其拷贝给 `dp`。

```cpp
int findLength(vector<int>& nums1, vector<int>& nums2)
{
    int m = nums1.size(), n = nums2.size(), len = 0;
    vector<int> dp(n + 1, 0);
    for (int i = m - 1; i >= 0; --i)
    {
        vector<int> newDp(n + 1, 0);
        for (int j = n - 1; j >= 0; --j)
        {
            if (nums2[j] == nums1[i])
            {
                newDp[j] = dp[j + 1] + 1;
                len = max(len, newDp[j]);
            }
        }
        dp = newDp;
    }

    return len;
}
```
