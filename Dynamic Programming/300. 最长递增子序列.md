问题链接：https://leetcode.cn/problems/longest-increasing-subsequence/description/

该题的贪心 + 二分查找解法可参考 []()。

# 解法：动态规划

定义一维数组 `dp[nums.size()]`，`dp[i]` 表示在子序列 `nums[0...i]` 中，**以 `nums[i]` 结尾**的最长递增子序列的长度。

由于一个元素就可以构成一个递增子序列，所以所有 `dp` 值初始时都为1。

### 推导 `dp[i]`

遍历数组 `1 <= i < nums.size()`，对于以 `nums[i]` 为结尾的最长递增子序列的长度，需要根据子序列 `nums[0...i - 1]` 推导。

首先要明确一个概念，最长递增子序列**不一定唯一**，比如 `{1,0,7,4}` 就有 `{1,7}`、`{1,4}` 和 `{0, 4}` 三个最长递增子序列。我们用 `S[i]` 表示子序列 `nums[0...i]` 中以 **`nums[i]` 结尾的**最长递增子序列。

遍历子序列 `0 <= j < i`。若 `nums[j] < nums[i]`，那么将 `nums[i]` 放到以 `S[j]` 最后面，就可以构成 `S[i]`。所以 `dp[i] = dp[j] + 1`；反之 `nums[i]` 维持不变。

$$dp[i] = max(dp[i],\ dp[j] + 1) $$

最终返回的结果就是 `dp` 中的最大值。

```cpp
int lengthOfLIS(vector<int>& nums)
{
    vector<int> dp(nums.size(), 1);
    for (int i = 1; i < nums.size(); ++i)
    {
        for (int j = 0; j < i; ++j)
            if (nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1);
    }

    return *max_element(dp.begin(), dp.end());
}
```
