问题链接：https://leetcode.cn/problems/longest-common-subsequence/description/

此题的前置题是 [718. 最长重复子数组.md](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)，题解在 [718. 最长重复子数组.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/718.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.md)，建议做完前置题再来做此题。

# 解法：动态规划

此题与前置题的区别在于，**不要求子序列连续**。

定义 `m` 保存 `text1` 的长度，`n` 保存 `text2` 的长度（长度加1防止访问越界）。定义二维数组 `dp[m + 1][n + 1]`，`dp[i][j]` 表示子序列 `text1[i...m - 1]` 和 `text2[j...n - 1]` **最长公共子序列**的长度。

以 `text1 = {'a','b','c','d','e'}`, `text2 = {'a','f','c','f','e'}` 为例。当 `i = 2`，`j = 2` 时，`dp[2][2]` 表示的是子序列 `text1[2...4] = {'c','d','e'}` 和 `text2[2...4] = {'c','f','e'}` 的最长公共子序列的长度。这个公共子序列是 `{'c','e'}`，所以有 `dp[2][2] = 2`。

### 推导 `dp[i][j]`

我们仍然从后向前遍历两个字符串的所有字符。
- 若 `text1[i] != text2[j]`，第一个字符不匹配，我们不能像前置题一样直接跳过去。

比如序列 `s1 = {'a','b','e','c'}` 和 `s2 = {'c','b','a','f'}`，去除首字符后的子序列分别为 `t1` 和 `t2`。尽管 `s1` 和 `s2` 的第一个字符不相等，但这并不能说明它们的公共子序列长度就为0。因为 `t1` 和 `s2`，`t2` 和 `s1`，甚至是 `t1` 和 `t2` 这几个子序列的组合，仍然有可能存在公共子序列。所以此时 `s1` 和 `s2` 的最大公共子序列的长度，应该等于所有组合情况下的最大值。因此有：

$$dp[i][j] = max(dp[i][j],\ max(dp[i + 1][j + 1],\ max(dp[i + 1][j],\ dp[i][j + 1])))$$

- 若 `text1[i] = text2[j]`，说明两个子序列中第一个字符是相等的。因为第一个字符是相等的，它们和子序列 `text1[i + 1...m - 1]` 和 `text2[j + 1...n - 1]` 的最长公共子序列组合后，就构成了一个新的最长公共子序列。因此有：

$$dp[i][j] = dp[i + 1][j + 1] + 1$$

有这个就可以知道，`dp[i + 1][j + 1]` 的状态最后都会转移到 `dp[i + 1][j]` 和 `dp[i][j + 1]` 中。因此在第一个字符不匹配时，我们不需要比较所有的组合，只需要比较 `dp[i + 1][j]` 和 `dp[i][j + 1]` 谁更大即可，因此有：

$$dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])$$

交换两个数组的遍历顺序，结果不变。`dp[0][0]` 表示的是两个字符串的最长公共子序列的长度，所以最后结果是 `dp[0][0]`。

```cpp
int longestCommonSubsequence(string text1, string text2)
{
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for (int i = m - 1; i >= 0; --i)
    {
        for (int j = n - 1; j >= 0; --j)
        {
            if (text2[j] == text1[i]) dp[i][j] = dp[i + 1][j + 1] + 1;
            else dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]);
        }
    }

    return dp[0][0];
}
```

# 解法：优化空间复杂度

以 `text1` 为行遍历，`text2` 为列遍历时，遍历的顺序是由右往左，由下往上的。因此 `dp[i + 1][j + 1]` 处于 `dp[i][j]` 的下一行。因此在内层循环前定义一个 `newDp`，来保存更新后的 `dp`，在内层循环结束后将其拷贝给 `dp`。

```cpp
int longestCommonSubsequence(string text1, string text2)
{
    int m = text1.size(), n = text2.size();
    vector<int> dp(n + 1, 0);
    for (int i = m - 1; i >= 0; --i)
    {
        vector<int> newDp(n + 1, 0);
        for (int j = n - 1; j >= 0; --j)
        {
            if (text2[j] == text1[i]) newDp[j] = dp[j + 1] + 1;
            else newDp[j] = max(dp[j], newDp[j + 1]);
        }
        dp = newDp;
    }

    return dp[0];
}
```
