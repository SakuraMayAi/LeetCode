问题链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/

关于动态规划的知识，可以参考：[0-1背包、完全背包、滚动数组以及装满背包排列组合个数求解](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/Algorithms%20And%20Data%20Structure/0-1%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E8%A3%85%E6%BB%A1%E8%83%8C%E5%8C%85%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E4%B8%AA%E6%95%B0%E6%B1%82%E8%A7%A3.md)。

此题的前置题是 [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)，题解在 [122. 买卖股票的最佳时机 II.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md)，建议做完前置题再来做此题。

# 解法：动态规划

由于在任何时候最多只能持有一只股票，且最多只能进行两次交易，一次交易对应的是**购买和出售**（前置题对交易次数无限制），所以在每一天结束后会有五种状态：

- 状态1：**没有**进行过交易，**没有股票**，`dp[0]`。
- 状态2：**没有**进行过交易，**持有股票**，`dp[1]`。
- 状态3：进行过**一次**交易，**没有股票**，`dp[2]`。
- 状态4：进行过**一次**交易，**持有股票**，`dp[3]`。
- 状态5：进行过**两次**交易，**没有股票**，`dp[4]`。

定义一维数组 `dp[5]`，分别表示这五种下的**最大利润**。

没有股票的原因是**出售股票**，或者前一天也没有股票且当天**仍未购买**；持有股票的原因是当天**购买股票**，或者前一天也持有股票且当天**继续持有**。状态1显然是没有购买，最大利润为0。

第 `i = 0` 天时，在这之前没有购买过股票。因此在第0天结束后，没有股票则为没有购买，最大利润是0；持有股票则为购买了，最大利润会减少为 `-prices[0]`；而在这一天进行过交易的话，利润实际上还是0（以同样的价格购买和出售）。所以临界条件为：`dp[1] = dp[3] = -prices[0]`， `dp[2] = dp[4] = 0`。

遍历所有价格，`1 <= i <= prices.size()`，对于第 `i` 天结束后各状态下的最大利润，需要根据第 `i - 1` 天结束后的情况计算。分别用 `~dp[]` 来表示第 `i - 1` 天结束后各状态下的最大利润。

### 推导 `dp[1]`：没有进行过交易，持有股票

第 `i` 天结束后处于状态2，那么第 `i - 1` 天结束后只可能处于状态1或者状态2：

- 如果第 `i - 1` 天结束后处于状态1，那么第 `i` 天就是**购买股票**。所以最大利润等于 `~dp[0]` 减去购买花费 `prices[i]`；
- 如果第 `i - 1` 天结束后处于状态2，那么第 `i` 天就是**继续持有**。所以最大利润等于 `~dp[1]`。

$$dp[1] = max(\sim dp[1],\ \sim dp[0] - prices[i])$$

### 推导 `dp[2]`：进行过一次交易，没有股票

第 `i` 天结束后处于状态3，那么第 `i - 1` 天结束后只可能处于状态2或者状态3：

- 如果第 `i - 1` 天结束后处于状态2，那么第 `i` 天就是**出售股票**。所以最大利润等于 `~dp[1]` 加上出售所得 `prices[i]`；
- 如果第 `i - 1` 天结束后处于状态3，那么第 `i` 天就是**仍未购买**。所以最大利润等于 `~dp[2]`。

$$dp[2] = max(\sim dp[2], \sim dp[1] + prices[i])$$

同理可以继续推得：

$$dp[3] = max(\sim dp[3], \sim dp[2] - prices[i])$$

$$dp[4] = max(\sim dp[4], \sim dp[3] + prices[i])$$

在这里，既可以采用二维数组 `dp[prices.size()][4]`（参考 [122. 买卖股票的最佳时机 II.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md) 的第一个解法）；也可以在循环中定义四个整型变量来保存第 `i` 天的状态值，然后保存到 `dp[1...4]` 中（参考 [122. 买卖股票的最佳时机 II.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md) 的第二个解法）。

在这里提供一个新思路：由 `dp[2] = max(~dp[2], ~dp[1] + prices[i])` 可知，在计算 `dp[2]` 时，我们需要用到 `~dp[1]`。但实际上，`~dp[1]` 可以直接用 `dp[1]` 替换。解释如下：

由前面的推导可知，`dp[2] = ~dp[1] + prices[i]` 对应的是前一天持有股票，当天出售股票后的最大利润。既然是前一天持有股票，对于 `dp[1]` 来说，其就是前一天处于状态2，当天继续持有的情况，也因此 `dp[1] = ~dp[1]`。因此在 `dp[2]` 的推导中，我们可以直接由当天的 `dp[1]` 推导当天的 `dp[2]`。

而且由前面的推导过程也可以知道，当天的状态2依赖于前一天的状态1和状态2，当天的状态3依赖于前一天的状态2和状态3。也就是说，当天靠后的状态值，其实都可以基于靠前的状态值推导出来。从而就不需要定义新的整型变量来保存当天的状态值。

综上所述，最终，所有的状态都会转移到 `dp[4]` 中，因此最后返回的结果就是 `dp[4]`。

```cpp
int maxProfit(vector<int>& prices)
{
    vector<int> dp(5, 0);
    dp[1] = dp[3] = -prices[0], dp[2] = dp[4] = 0;
    for (int i = 1; i < prices.size(); ++i)
    {
        dp[1] = max(dp[1], dp[0] - prices[i]);
        dp[2] = max(dp[2], dp[1] + prices[i]);
        dp[3] = max(dp[3], dp[2] - prices[i]);
        dp[4] = max(dp[4], dp[3] + prices[i]);
    }

    return dp[4];
}
```
