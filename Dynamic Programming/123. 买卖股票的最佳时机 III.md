问题链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/

关于动态规划的知识，可以参考：[0-1背包、完全背包、滚动数组以及装满背包排列组合个数求解](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/Algorithms%20And%20Data%20Structure/0-1%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E8%A3%85%E6%BB%A1%E8%83%8C%E5%8C%85%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E4%B8%AA%E6%95%B0%E6%B1%82%E8%A7%A3.md)。

此题的前置题是 [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)，题解在 [122. 买卖股票的最佳时机 II.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md)，建议做完前置题再来做此题。

# 解法：动态规划

由于在任何时候最多只能持有一只股票，且最多只能进行两次交易，一次交易对应的是购买和出售（前置题对交易次数无限制），所以在每一天结束后会有五种状态：

- 第一种：**没有**进行过交易，**没有股票**。
- 第二种：**没有**进行过交易，**持有股票**，`dp[0]`。
- 第三种：进行过**一次**交易，**没有股票**，`dp[1]`。
- 第四种：进行过**一次**交易，**持有股票**，`dp[2]`。
- 第五种：进行过**两次**交易，**没有股票**，`dp[3]`。

定义一维数组 `dp[4]`，分别表示后面四种状态下的**最大利润**。没有股票的原因是**当天出售了，或者不购买**；持有股票的原因是**当天购买了，或者不出售**。第一种状态显然是没有购买，且最大利润为0，我们不作考虑。

在 `i = 0` 天时，在这之前没有购买过股票。因此在第0天结束后，持有股票则为购买了，最大利润会减少为 `-prices[0]`；而没有股票则为没有购买，最大利润是0。而在这一天进行过交易的话，利润实际上还是0（以同样的价格购买和出售）。所以临界条件为：`dp[0] = dp[2] = -prices[0]`， `dp[1] = dp[3] = 0`。

遍历所有价格，`1 <= i <= prices.size()`，对于第 `i` 天结束后各状态下的最大利润，需要根据第 `i - 1` 天结束后的情况计算，分别用 `~dp[]` 来表示第 `i - 1` 天结束后各状态下的最大利润。

### `dp[0]`
对于 `dp[0]`，在这之前没有进行过交易。在第 `i` 天结束后持有股票只有两种情况：**继续持有**和**购买股票**。
- 继续持有的情况下，最大利润和第 `i - 1` 天的第二种状态保持一致，即 `dp[0] = ~dp[0]`。
- 购买股票的情况下，最大利润需要减去买入花费，而由于之前没有进行过交易，最大利润是0，所以 `dp[0] = -prices[i]`。

`dp[0]` 应该是这两种情况下的最大值，即 `dp[0] = max(~dp[0], -prices[i])`。

### `dp[1]`

对于 `dp[1]`，在这之前进行过一次交易。在第 `i` 天结束后没有股票只有两种情况：**仍未购买**和**出售股票**。
- 仍未购买的情况下，最大利润和第 `i - 1` 天的第三种状态保持一致，即 `dp[1] = ~dp[1]`。
- 出售股票的情况下，最大利润就是第 `i - 1` 天的第二种状态下的最大利润，加上今天卖出所得，即 `dp[1] = ~dp[0] + prices[i]`。

`dp[1]`应该是这两种情况下的最大值，即 `dp[1] = max(~dp[1], ~dp[0] + prices[i])`。

同理可以得到 `dp[2] = max(~dp[2], dp[1] - prices[i])`，`dp[3] = max(~dp[3], ~dp[2] + prices[i])`。

总的状态转移方程就是：

```cpp
dp[0] = max(~dp[0], -prices[i])
dp[1] = max(~dp[1], ~dp[0] + prices[i])
dp[2] = max(~dp[2], ~dp[1] - prices[i])
dp[3] = max(~dp[3], ~dp[2] + prices[i])
```

在这里，既可以采用二维数组 `dp[prices.size()][4]`（参考 [122. 买卖股票的最佳时机 II.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md) 的第一个解法）；也可以在循环中定义四个整型变量来保存第 `i` 天的状态值，然后保存到 `dp[0...3]` 中（参考 [122. 买卖股票的最佳时机 II.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md) 的第二个解法）。

在这里提供一个新思路：由 `dp[1] = max(~dp[1], ~dp[0] + prices[i])` 可知，在计算 `dp[1]` 时，我们需要用到 `~dp[0]`。但实际上，`~dp[0]` 可以直接用 `dp[0]` 替换。解释如下：

`dp[0] = max(~dp[0], -prices[i])` 的结果其实只有一个，那就是 `-prices[i]`。由前面状态转移方程的推导可知，若是购买股票，最大利润就是 `-prices[i]`；若是**继续持有**，最大利润和第 `i - 1` 天保持一致，而第 `i - 1` 天的最大利润也一定是购买了股票后的结果。所以 `dp[0]` 只可能等于 `prices[i]`，从而将其替换掉 `~dp[0]` 完全没有问题。

以此类推，靠后面的状态值，都可以通过靠前面的状态值计算出来，从而就不需要定义新的整型变量来保存当天的状态值。而且，所有的状态值（最大利润）最后都会转移到 `dp[3]` 中，因此最后的结果就是 `dp[3]`。

```cpp
int maxProfit(vector<int>& prices)
{
    vector<int> dp(4, 0);
    dp[0] = dp[2] = -prices[0], dp[1] = dp[3] = 0;
    for (int i = 1; i < prices.size(); ++i)
    {
        dp[0] = max(dp[0], -prices[i]);
        dp[1] = max(dp[1], dp[0] + prices[i]);
        dp[2] = max(dp[2], dp[1] - prices[i]);
        dp[3] = max(dp[3], dp[2] + prices[i]);
    }

    return dp[3];
}
```
