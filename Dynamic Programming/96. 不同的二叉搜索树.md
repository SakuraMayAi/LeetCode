问题链接：https://leetcode.cn/problems/unique-binary-search-trees/description/

# 解法：动态规划

假设 `dp[i]` 表示 `i` 个节点可以构成的二叉搜索树的种数。对于每一个 `dp[i]` 的求解我们可以按如下过程进行分解：
1. `i = 1`，一个节点只能构成一种二叉搜索树。所以 **`dp[1] = 1`**。
2. `i = 2`，两个节点可以分成：
**以1为根节点**和**以2为根节点**的二叉搜索树。问题转化为求以1为根节点的二叉搜索树种树 + 以2为根节点二叉搜索树种数。因为除去根节点后，子树只有一个节点，所以 **`dp[2] = dp[1] + dp[1] = 2`**。
3. `i = 3`，三个节点可以分成：
**以1为根节点**、**以2为根节点**和**以3为根节点**的二叉搜索树。问题转化为求以1为根节点的二叉搜索树种树 + 以2为根节点的二叉搜索树种树 + 以3为根节点的二叉搜索树种树。
以1为根节点时，子树有两个节点，所以种树为 `dp[2] = 2`；以2为根节点时，左右子树各只有一个节点，所以种树为 `dp[1] * dp[1] = 1`；以3为根节点时，与以1为根节点时对称，所以种树为 `dp[2] = 1`。最后，**`dp[3] = 2 + 1 + 2 = 5`**。
4. `i = 4`，四个节点可以分成：
**以1为根节点**、**以2为根节点**、**以3为根节点**和**以4为根节点**的二叉搜索树。问题转化为求以1为根节点的二叉搜索树种树 + 以2为根节点的二叉搜索树种树 + 以3为根节点的二叉搜索树种树 + 以4为根节点的二叉搜索树种树。
以1为根节点时，子树有三个节点，所以种树为 `dp[3] = 5`；以2为根节点时，左子树有一个节点，右子树有两个节点，所以种树为 `dp[1] * dp[2] = 2`；以3为根节点时，与以2为根节点时对称；以4为根节点时，与以1为根节点时对称。所以最后，**`dp[4] = 5 + 2 + 2 + 5 = 14`**。


用 `i` 来枚举总的节点数，用 `j` 来枚举**谁做根节点**。对于以 `j` 为根节点的树，其左子树的节点数为 `j - 1`，右子树的节点数为 `i - j`，所以以 `j` 为根节点的二叉搜索树种树为 `dp[j - 1] * dp[i - j]`。其次要注意的是，可以通过对称来减少计算量。当 `i` 为偶数时，计算一半节点的种树，结果乘2即可。当 `i` 为奇数时，乘上2后，要减去以最中间节点为根节点的种树（重复计算了）。

```cpp
int numTrees(int n)
{
    vector<int> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; ++i)
    {
        for (int j = 1; j <= (i - 1) / 2; ++j)
            dp[i] += dp[j - 1] * dp[i - j];
        if (i % 2 == 0) dp[i] *= 2;
        else dp[i] = dp[i] * 2 - dp[(i - 1) / 2] * dp[(i - 1) / 2];
    }

    return dp[n];
}
```
