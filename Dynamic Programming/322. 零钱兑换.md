问题链接：https://leetcode.cn/problems/coin-change/submissions/563854300/

# 解法：动态规划

关于完全背包问题可以参考 [0-1背包、完全背包、滚动数组以及排列个数求解.md](https://github.com/SakuraMayAi/Tricks-of-Programming/blob/main/Data%20Structure/0-1%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E6%8E%92%E5%88%97%E4%B8%AA%E6%95%B0%E6%B1%82%E8%A7%A3.md)，写的非常的详细。

此题就是经典的完全背包问题。`dp[j]` 表示凑成总金额 j 的最少硬币数。在二维数组 `dp` 中，当 `j = 0` 需要凑成的总金额为0，那么需要的硬币数就是0，所以 dp[0] = 0。而其他元素初值为 INT_MAX，用 unsigned int 定义 dp 元素的类型，是因为 int 类型变量最大值加1后会溢出成为负数。因为求的是最少需要的硬币数，所以需要比较两种方案下的最小值。

```cpp
int coinChange(vector<int>& coins, int amount)
{
    vector<unsigned int> dp(amount + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 0; i < coins.size(); ++i)
        for (int j = coins[i]; j <= amount; ++j)
            dp[j] = min(dp[j], dp[j - coins[i]] + 1);

    return dp[amount] != INT_MAX ? dp[amount] : -1; // 无法凑成时，dp[amount] 仍然为 INT_MAX
}
```
