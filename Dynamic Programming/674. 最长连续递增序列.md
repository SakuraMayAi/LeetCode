问题链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/

本题的双指针法可参考 [674. 最长连续递增序列.md](https://github.com/SakuraMayAi/LintCode/blob/main/Array/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.md)。

# 解法：动态规划

定义一维数组 `dp[nums.size()]`，`dp[i]` 表示在子序列 `nums[0...i]` 中，**以 `nums[i]` 结尾**的连续递增子序列的长度。

由于一个元素就可以构成一个递增子序列，所以所有 `dp` 值初始时都为1。

### 推导 `dp[i]`

遍历数组 `1 <= i < nums.size()`，对于以 `nums[i]` 结尾的连续递增子序列的长度，若 `nums[i] > nums[i - 1]`，说明它俩可以继续构成连续递增子序列，所以 `dp[i] = dp[j] + 1`；反之 `dp[i]` 仍为初始值1。

最终返回的结果就是 `dp` 中的最大值。

```cpp
int findLengthOfLCIS(vector<int>& nums)
{
    vector<int> dp(nums.size(), 1);
    for (int i = 1; i < nums.size(); ++i)
        if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;

    return *max_element(dp.begin(), dp.end());
}
```
