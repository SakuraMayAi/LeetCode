
问题链接：https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/

此题的前置题是 [1143. 最长公共子序列.md](https://leetcode.cn/problems/longest-common-subsequence/description/)，题解在 [1143. 最长公共子序列.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.md)，建议做完前置题再来做此题。

本题的双指针法可参考 []()。

# 解法：动态规划

如果前置题理解了，那么这一题就好做了。如果最后得到的最长公共子序列的长度等于字符串 `s` 的长度，就说明 `s` 是 `t` 的子序列。

```cpp
bool isSubsequence(string s, string t)
{
    int m = t.size(), n = s.size();
    vector<int> dp(n + 1, 0);
    for (int i = m - 1; i >= 0; --i)
    {
        vector<int> newDp(n + 1, 0);
        for (int j = n - 1; j >= 0; --j)
        {
            if (s[j] == t[i]) newDp[j] = dp[j + 1] + 1;
            else newDp[j] = max(dp[j], newDp[j + 1]);
        }
        dp = newDp;
    }

    return dp[0] == s.size();
}
```
