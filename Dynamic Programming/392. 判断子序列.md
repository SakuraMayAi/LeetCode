问题链接：https://leetcode.cn/problems/is-subsequence/description/

此题的前置题是 [1143. 最长公共子序列.md](https://leetcode.cn/problems/longest-common-subsequence/description/)，题解在 [1143. 最长公共子序列.md](https://github.com/SakuraMayAi/LintCode/blob/main/Dynamic%20Programming/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.md)，建议做完前置题再来做此题。

本题的贪心 + 双指针法可参考 [392. 判断子序列.md](https://github.com/SakuraMayAi/LintCode/blob/main/Greedy%20Strategy/392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.md)。

# 解法一：动态规划

如果前置题理解了，那么这一题就好做了。如果最后得到的最长公共子序列的长度等于字符串 `s` 的长度，就说明 `s` 是 `t` 的子序列。

```cpp
bool isSubsequence(string s, string t)
{
    int m = t.size(), n = s.size();
    vector<int> dp(n + 1, 0);
    for (int i = m - 1; i >= 0; --i)
    {
        vector<int> newDp(n + 1, 0);
        for (int j = n - 1; j >= 0; --j)
        {
            if (s[j] == t[i]) newDp[j] = dp[j + 1] + 1;
            else newDp[j] = max(dp[j], newDp[j + 1]);
        }
        dp = newDp;
    }

    return dp[0] == s.size();
}
```

# 解法二：动态规划 + 哈希

> 进阶：
> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

对于进阶问题，如果还采用解法一就不可取了。这么多次的查询，每次都要计算新的 dp 会耗费相当多的时间。在此处我们可以先通过动态规划建立一个哈希表，再通过哈希表去匹配 $S$ 中的每一个字符，速度就会快很多了。具体可以参考 []()。

```cpp
bool isSubsequence(string s, string t)
{
    int n = t.size();
    vector<vector<int>> dp(n + 1, vector<int>(26, 0));
    for (auto& i : dp[n]) i = n;

    for (int i = n - 1; i >= 0; --i)
        for (int j = 0; j < 26; ++j)
            dp[i][j] = (t[i] == j + 'a') ? i : dp[i + 1][j];

    for (int i = 0, j = 0; j < s.size(); ++j)
    {
        if (dp[i][s[j] - 'a'] == n) // 到达主串末尾
            return false;
        i = dp[i][s[j] - 'a'] + 1;  // i 跳转到下一个位置进行匹配
    }

    return true;
}
```
