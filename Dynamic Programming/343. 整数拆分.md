问题链接：https://leetcode.cn/problems/integer-break/description/

# 解法一：动态规划

假设 `dp[i]` 表示整数 `i` 拆分后可以获得的最大乘积。我们可以通过两种方式得到 `dp[i]`，一个是 `j * (i - j)`，另一个就是 `j * dp[i - j]`，`dp[i - j]` 相当于将 `i - j` 进行拆分。别看这两个长的像，实际上结果相差很大。循环建立在 `j` 从1枚举到 `i  -1`，而在某一轮循环中得到的 `dp[i]` 可能已经是最大的 `dp[i]` 了，所以在求最大值时，还需要将 `dp[i]` 放进去一起比较。另外，`j` 实际上不需要枚举到 `i - 1`，因为通过规律可以发现，要使一个数拆被拆分之后各项乘积最大，那么一定是拆分成**数个近似相同**的子数相乘才是最大的。比如6要拆成 `3 + 3` 而不是 `2 + 4`，再比如9要拆成 `3 + 3 + 3` 而不是 `4 + 5`。所以 `j` 最大也只需要枚举到 `i / 2`。

```cpp
int integerBreak(int n)
{
    vector<int> dp(n + 1);
    dp[2] = 1;
    for (int i = 3; i <= n; ++i)
        for (int j = 1; j <= i / 2; ++j)
            dp[i] = max(dp[i], max(j* (i - j), j * dp[i - j]));

    return dp[n];
}
```

# 解法二：贪心

先观察下面的式子：

1. `2 = 1 + 1`，`dp[2] = 1 * 1 = 1 < 2`。
2. `3 = 1 + 2`，`dp[3] = 1 * 2 = 2 < 3`。
3. `4 = 2 + 2`，`dp[4] = 2 * 2 = 4 = 4`。
4. `5 = 2 + 3`，`dp[5] = 2 * 3 = 6 > 5`。
5. `6 = 3 + 3`，`dp[3] = 3 * 3 = 9 > 6`。

可以发现，从 `dp[5]` 往后，`dp` 值实际上已经超过 `i` 了。所以拆分后面的数时，如果拆成了 `5 + XX`，就应该将5继续拆分成 `2 + 3`，因为拆分成5得到的乘积要小于拆分成 `2 + 3`。也即将所有**大于4的数**，都拆分成**4以内**的数之和，否则其乘积就会变小（或者说如果不继续拆，就**不值当**了）。

而且由解法一中讨论的规律可知：要使一个数拆被拆分之后各项乘积最大，那么一定是拆分成**数个近似相同**的子数相乘才是最大的。所以将数尽可能的拆分成3，剩下的分给2或者4即可。因为如果按4均分，最后剩余的数就有可能是1或者2，和4相差太大。而按照3进行均分，余数只会是2或者4（循环的条件是 `n > 4`），离3都很接近，也满足我们的规律。

```cpp
int integerBreak(int n)
{
    if (n == 2) return 1;
    if (n == 3) return 2;
    if (n == 4) return 4;
    int res = 1;
    while (n > 4)
    {
        res *= 3;
        n -= 3;
    }
    res *= n;

    return res;
}
```
